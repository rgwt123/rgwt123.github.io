---
layout:     post			    # 使用的布局（不需要改）
title:      leetcode解题思路记录(持续更新~) 				# 标题 
subtitle:   始于2020 0531~ #副标题
date:       2020-05-31 				# 时间
author:     Tao				# 作者
header-img: img/post-bg-universe.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 算法
---

### 动态规划

#### 编辑距离
给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

搜索空间很大，定义D[i][j]为word1的前i个字符和word2的前j个字符的最短编辑距离。

~~~python
'''
input:
"horse"
"ros"

output:
3
'''
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        '''
          @ h o r s e
        @ 0 1 2 3 4 5
        r 1 1 2 2 3 4
        o 2 2 1 2 3 4
        s 3 3 2 2 2 3

        from empty
        if a_end == b_end : 1+min(D[i-1,j],D[i,j-1],D[i-1,j-1]-1)
        else : 1+min(D[i-1,j],D[i,j-1],D[i-1,j-1])
        '''
        D = []
        for i in range(len(word2)+1):
            D.append([0]*(len(word1)+1))
        
        for i in range(len(word2)+1):
            D[i][0] = i
        
        for i in range(len(word1)+1):
            D[0][i] = i

        for i in range(1, len(word2)+1):
            for j in range(1, len(word1)+1):
                if word2[i-1] == word1[j-1]:
                    D[i][j] = 1 + min(D[i-1][j], D[i][j-1], D[i-1][j-1]-1)
                else:
                    D[i][j] = 1 + min(D[i-1][j], D[i][j-1], D[i-1][j-1])
                
        return D[-1][-1]
~~~

### 双指针


### 二叉树

### 图算法
