---
layout:     post			    # 使用的布局（不需要改）
title:      leetcode解题思路记录(持续更新~) 				# 标题 
subtitle:   始于2020 0531~ #副标题
date:       2020-05-31 				# 时间
author:     Tao				# 作者
header-img: img/post-bg-universe.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 算法
---

[参考博客](https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie)


### 动态规划
#### 常见的题目类型：

斐波那契数列 零钱问题 最长递增子序列 最大子数组 背包问题/各种变种 编辑距离 扔鸡蛋问题 戳气球 最长公共子序列 博弈问题 正则表达 KMP字符匹配 区间调度 股票买卖 打家劫舍

#### 关键点
动态规划的一般形式就是求最值，比如最少需要多少枚硬币，最少操作数等。

核心是穷举所有可能，但避免重复计算。

具备最优子结构，需要列出正确的状态转移方程。

套路：明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。

自顶向下一般都可以画出一颗递归树，存在很多冗余；自底向上一般使用一维数组或者二维数组当作dp table来求解。

```python
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

#### 编辑距离
给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

搜索空间很大，定义D[i][j]为word1的前i个字符和word2的前j个字符的最短编辑距离。

```python
'''
input:
"horse"
"ros"

output:
3
'''
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        '''
          @ h o r s e
        @ 0 1 2 3 4 5
        r 1 1 2 2 3 4
        o 2 2 1 2 3 4
        s 3 3 2 2 2 3

        from empty
        if a_end == b_end : 1+min(D[i-1,j],D[i,j-1],D[i-1,j-1]-1)
        else : 1+min(D[i-1,j],D[i,j-1],D[i-1,j-1])
        '''
        D = []
        for i in range(len(word2)+1):
            D.append([0]*(len(word1)+1))
        
        for i in range(len(word2)+1):
            D[i][0] = i
        
        for i in range(len(word1)+1):
            D[0][i] = i

        for i in range(1, len(word2)+1):
            for j in range(1, len(word1)+1):
                if word2[i-1] == word1[j-1]:
                    D[i][j] = 1 + min(D[i-1][j], D[i][j-1], D[i-1][j-1]-1)
                else:
                    D[i][j] = 1 + min(D[i-1][j], D[i][j-1], D[i-1][j-1])
                
        return D[-1][-1]
```

#### 股票买卖问题


### 回溯算法
#### 常见的题目类型：

全排列 N皇后

#### 关键点
回溯其实也是一个决策树的遍历过程，但是需要不停回溯。

关键在于确定路径，选择列表，结束条件。

回溯法不像DP有重叠子问题可以优化，一般都是暴力穷举。

某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。

```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

### BFS广度优先搜索
#### 常见的题目类型：
二叉树最小深度 打开转盘锁

#### 关键点
DFS算法就是回溯法，BFS算法需要维护一个队列，先入先出，层层遍历。

BFS算法找到的路径一般是最短的，但是空间复杂度相对较高。

```cpp
// 计算从起点 start 到终点 target 的最近距离
int BFS(Node start, Node target) {
    Queue<Node> q; // 核心数据结构
    Set<Node> visited; // 避免走回头路

    q.offer(start); // 将起点加入队列
    visited.add(start);
    int step = 0; // 记录扩散的步数

    while (q not empty) {
        int sz = q.size();
        /* 将当前队列中的所有节点向四周扩散 */
        for (int i = 0; i < sz; i++) {
            Node cur = q.poll();
            /* 划重点：这里判断是否到达终点 */
            if (cur is target)
                return step;
            /* 将 cur 的相邻节点加入队列 */
            for (Node x : cur.adj())
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
        }
        /* 划重点：更新步数在这里 */
        step++;
    }
}
```

### 二分搜索
#### 常见的题目类型：
二分查找 在排序数组中查找元素的第一个和最后一个位置

#### 关键点
一般都是排序数组中操作的

需要注意区间开闭以及边界条件+1 -1

```cpp
int binary_search(int[] nums, int target) {
    int left = 0, right = nums.length - 1; 
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1; 
        } else if(nums[mid] == target) {
            // 直接返回
            return mid;
        }
    }
    // 直接返回
    return -1;
}

int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定左侧边界
            right = mid - 1;
        }
    }
    // 最后要检查 left 越界的情况
    if (left >= nums.length || nums[left] != target)
        return -1;
    return left;
}


int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定右侧边界
            left = mid + 1;
        }
    }
    // 最后要检查 right 越界的情况
    if (right < 0 || nums[right] != target)
        return -1;
    return right;
}
```

### 双指针
#### 常见的题目类型：
快慢指针： 判断链表是否有环，返回环的起始位置，寻找链表的中点，链表的倒数第k个元素。

左右指针： 二分查找，两数之和，反转数组，滑动窗口


#### 关键点
双指针分为两类，一类是「快慢指针」，一类是「左右指针」。前者主要解决链表问题，后者主要解决字符串/数组问题。

只要数组有序，就应该想到双指针。




### 滑动窗口
#### 常见的题目类型：
最小覆盖子串 字符串排列 找到字符串中所有字母异位词 无重复字符的最长子串

#### 关键点
关键在于决定移动左边指针还是右边指针，这个条件需要写很多判断代码。

滑动的窗口一般用哈希表字典，也可以用数组之类的。

```cpp
int left = 0, right = 0;

while (right < s.size()) {
    window.add(s[right]);
    right++;

    while (valid) {
        window.remove(s[left]);
        left++;
    }
}
```

### 二叉树

### 图算法
